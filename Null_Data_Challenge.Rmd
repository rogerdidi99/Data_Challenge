---
title: "Null_Data_Challenge"
author: "Roger Yuan"
date: "9/3/2019"
output: pdf_document
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Import Datasets
```{r echo=FALSE, message=FALSE, warning=FALSE}
library(readr)
library(tidyverse)
# Roger
ride_ids <- read_csv("~/Desktop/Lyft Data Challenge/Lyft Data/ride_ids.csv")
driver_ids <- read_csv("~/Desktop/Lyft Data Challenge/Lyft Data/driver_ids.csv")
ride_timestamps <- read_csv("~/Desktop/Lyft Data Challenge/Lyft Data/ride_timestamps.csv")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(readr)
library(tidyverse)
# Edwin
ride_ids <- read_csv("C:/Users/Edwin/Downloads/ride_ids.csv")
driver_ids <- read_csv("C:/Users/Edwin/Downloads/driver_ids.csv")
ride_timestamps <- read_csv("C:/Users/Edwin/Downloads/ride_timestamps.csv")
```

##Revenue for Each Driver
```{r echo=FALSE}
ride_ids$revenue <- round(1.75 + (2 + 0.22 * ride_ids$ride_duration/60 + 1.15 * 0.000621371 * ride_ids$ride_distance) * (1 + ride_ids$ride_prime_time/100), digits = 2)

ride_ids$revenue[ride_ids$revenue < 5] <- 5
ride_ids$revenue[ride_ids$revenue > 400] <- 400

ride_ids %>% 
  group_by(driver_id) %>% 
  summarise(total_rev = sum(revenue)) %>% 
  arrange(desc(total_rev))
```

# tag rides with time of day, sum up all prime time bonuses for drivers
```{r echo=FALSE}
# switch timezone
#attributes(ride_timestamps$timestamp)$tzone <- "America/Los_Angeles"

# morning rush hour 5-10
# evening rush hour 3-7
timeofday <- function(datetime) {
  num = as.numeric(strftime(datetime, format="%H"))
  if ((num < 5) | (num >= 19)) return("night")
  if ((5 <= num) & (num < 10)) return("morning rush")
  if ((10 <= num) & (num < 12)) return("morning")
  if ((12 <= num) & (num < 15)) return("afternoon")
  if ((15 <= num) & (num < 19)) return("evening rush")
  else return(NULL)
}

# assign time of day for ride based on accepted_at timestamp
acceptedat <- ride_timestamps[which(ride_timestamps$event == 'accepted_at'),]

# long function, has to run row by row
acceptedat$dayinfo <- apply(acceptedat, 1, function(x) {timeofday(x[3])})

ride_ids <- left_join(ride_ids, acceptedat[c("ride_id", "dayinfo")], by="ride_id")

# find total prime time bonus for each driver
sumprime <- aggregate(ride_ids$ride_prime_time, by=list(driver_id=ride_ids$driver_id), FUN=sum)
colnames(sumprime) <- c("driver_id", "totalprimetime")

# join totalprimetime bonus with driver_id table
# driver_ids <- inner_join(driver_ids, sumprime, by="driver_id")
# 
# temp <- ride_ids %>% 
#   group_by(driver_id) %>% 
#   summarise(total_rev = sum(revenue)) %>% 
#   arrange(desc(total_rev))
# 
# driver_ids <- inner_join(driver_ids, temp, by="driver_id")
```

##Driver's Lifetime
```{r echo=FALSE}
rides <- 
  ride_timestamps %>% 
  group_by(ride_id) %>% 
  summarise(latest_time = max(timestamp))

ride_ids2 <- inner_join(x = ride_ids, y = rides, by = "ride_id")

driver_times <- 
  ride_ids2 %>% 
  group_by(driver_id) %>% 
  summarise(latest_time = max(latest_time))

driver_lifetime <- inner_join(driver_ids, driver_times, "driver_id")
driver_lifetime$life_time <- driver_lifetime$latest_time - driver_lifetime$driver_onboard_date

driver_lifetime %>% arrange(desc(life_time))
mean(driver_lifetime$life_time, na.rm = T)
```

##Time Between Rides
```{r echo=FALSE}
Driver_timestamps <- left_join(x = ride_timestamps, y = ride_ids, by = "ride_id")

bruhh <- Driver_timestamps %>% 
  filter(event == "requested_at") %>% 
  arrange(timestamp) %>% 
  arrange(driver_id)

bruhh2 <- bruhh %>% select(driver_id, timestamp)
bruhh2$difference = c(NA, round(diff(bruhh2$timestamp)/60))
bruhh2

#K Means Clusters
Full_time <- kmeans(bruhh2[-1,]$difference, centers = 3)$cluster
table(Full_time)
```



##Big Inner Join
```{r echo=FALSE}
all_rides <- inner_join(x = ride_ids, y = driver_ids, by = "driver_id")

# ride_timestamps2 <- inner_join(x = ride_timestamps, y = ride_ids, by = "ride_id")
# ride_timestamps2 <- ride_timestamps2[1:4]

all_rides <- inner_join(x = all_rides, y = driver_lifetime[-2], by = "driver_id")


rush_name <- names(table(all_rides$dayinfo))
Driver_summary <- 
  all_rides %>% 
  group_by(driver_id) %>% 
  summarise(Total_Rev = sum(revenue), life_time = max(life_time), 
            Total_distance = sum(ride_distance), Total_duration = sum(ride_duration),
            Total_prime_time = sum(ride_prime_time), 
            Rush = rush_name[which.max(table(dayinfo))])

Driver_summary %>% arrange(desc(Total_Rev))

ride_ids %>% 
  group_by(driver_id) %>% 
  summarise(total_rev = sum(revenue)) %>% 
  arrange(desc(total_rev))

```


# investigate timestamps of outlier drivers
```{r echo=FALSE}
# driver id and revenue
driver_rev <- ride_ids %>% 
  group_by(driver_id) %>% 
  summarise(total_rev = sum(revenue)) %>% 
  arrange(desc(total_rev))

ride_timestamps <- inner_join(ride_ids[,c('driver_id', 'ride_id')], ride_timestamps, by='ride_id')

timediff <- function(time1, time2) {
  diff = difftime(time1, time2)
  if (units(diff) == "secs") {
    return(as.numeric(diff) / 60)
  }
  if (units(diff) == "hours") {
    return(as.numeric(diff) * 60)
  }
  return(as.numeric(diff))
}

# subtract dropped off from requested time
ride_summary <- aggregate(ride_timestamps$timestamp, by=list(ride_id=ride_timestamps$ride_id), FUN=function(x)timediff(range(x)[2], range(x)[1]))

#only pickedup and droppedoff
temp2 <- ride_timestamps[which(ride_timestamps$event == 'picked_up_at' | ride_timestamps$event == 'dropped_off_at'),]
travel_times <- aggregate(temp2$timestamp, by=list(ride_id=temp2$ride_id), 
                          FUN=function(x) timediff(range(x)[2], range(x)[1]))

# get times with no revenue
ride_summary$norider <- (ride_summary$x - travel_times$x)
colnames(ride_summary)[2] <- 'totaltime'

#ride_summary$totaltime <- as.numeric(ride_summary$totaltime)
ride_summary <- inner_join(ride_ids[,c('driver_id', 'ride_id')], ride_summary, by='ride_id')
ride_summary$percentnorev <- ride_summary$norider / ride_summary$totaltime
```


```{r echo=FALSE}
# driver ids with outlier revenue
driverid_out <- driver_rev$driver_id[which(driver_rev$total_rev %in% boxplot(driver_rev$total_rev)$out)]
ride_summary[which(ride_summary$driver_id %in% driverid_out),]
meannorev <- aggregate(ride_summary$percentnorev, by=list(driver_id=ride_summary$driver_id), FUN=mean)

# ride timestamps with outlier driver revenue
time_out <- ride_timestamps[which(ride_timestamps$driver_id %in% driverid_out),]
sumprime[which(sumprime$driver_id %in% driverid_out),]
head(sumprime[order(-sumprime$totalprimetime),], 8)
```


##OLS Regression Analysis
```{r echo=FALSE}
library(glmnet)
which(is.na(Driver_summary), arr.ind=TRUE)
Driver_summary[425, 3] <- median(Driver_summary[[3]], na.rm = T)

X <- model.matrix(Total_Rev ~., data = Driver_summary[,-1])[,-1]
Y <- Driver_summary$Total_Rev

#Creating 70% training, 30% testing data
set.seed(777)
train <- sample(1:nrow(X), round(0.7 * nrow(X)))
test <- (-train)
Y_test <- Y[test]

##OLS
driver_lm <- lm(Total_Rev ~ 0 + life_time + Total_distance + Total_duration
                + Total_prime_time, data = Driver_summary[,-1])
summary(driver_lm)

coef(driver_lm)

length(Y)

lassofit = glmnet(X, Y)
# we can see lasso will push a paramter value down to 0

as.matrix(t(coef(lassofit, s = 0.5))) 
```


```{r}
mean(ride_ids$revenue[which(ride_ids$dayinfo=='night')])
mean(driver_lifetime$life_time, na.rm=T)
lifetimesummary <- boxplot.stats(as.numeric(driver_lifetime$life_time))
lifetimesummary
```

# A driver's lifetime value should be calculated using their projected lifetime revenue, average prime time bonus per ride, and proportion of rides driven during rush hour or late nights. After normalizing each component we multiply them together to get a lifetime value.

# Revenue is often a good indicator of an employee's worth to a company. At the end of the day, an employee's contribution to their company's bottom line determines how important they are to the company, at least financially. To determine a driver's financial value, we found their average daily revenue by totaling the revenue of their rides during their lifetime and dividing by their lifetime before multiplying by the average driver lifetime. This revenue calculation accounts for prime time bonuses as well. 

# However, while revenue is important, it is not all a driver has to offer to Lyft. We believe that a driver who works for Lyft during times of high demand, such as special events, would be of much value to the company. Not only would they bring in more revenue due to prime time bonuses that are often in effect, but they bolster Lyft's consistency and dependency during times when people rely on them the most. Moreover, they increase Lyft's ability to contend against competitors when there are more potential riders unfamiliar with the service or are not loyal to a specific one. By allowing Lyft to provide its services to more riders during espcially busy and often crucial times, these drivers have increased worth towards Lyft that cannot be described by revenue alone.

# In order to represent this, we summed up all the prime time bonuses for each driver as an approximate measure of how often they drive during high demands. Larger total prime time bonuses indicate a tendency to work during busy times and lower totals indicate otherwise. We once again normalize this factor.

# One more factor we want to consider is how often a driver works during rush hours. This is somewhat similar to the previously mentioned total prime time, but the number of rides during rush hour or late nights represents a more consistent work schedule. Because riders who hail rides during these times often need to, often due to work, we believe Lyft drivers who work within these hours are not only fulfilling demand but also building customer loyalty. Because many regularly need rides during these times, they will tend to stick with a ride hailing company, and drivers who help saturate this market with Lyft options not only capitalize on revenue but also aid in creating repeat customers for Lyft. Due to their contributions towards brand marketing and loyalty, these drivers are also very valuable to Lyft.

# To get this information we labelled each ride with a time of day depending on when the ride was requested. We then summed up the number of rides that occured during rush hours (5-10am and 3-7pm) and once again normalized it.


# Driver Projected Lifetime

# The average projected lifetime of a driver is approximately 55.75 days, or a little under 2 months based on the data given. Furthermore, the minimum lifetime is 1.7 days, the first quartile is 43 days, the median is 58 days, the third quartile is 73 days, and the maximum is 91 days. The distribution of lifetimes is only slightly left skewed. We calculated the lifetime of a driver by subtracting their onboard date from their last recorded ride date. However, because the data was only representative of a 3 month period the projected lifetime in this dataset is likely shorter than the true projected lifetime of a Lyft driver.
```{r message=FALSE, warning=FALSE}
boxplot(as.numeric(driver_lifetime$life_time), main="Driver Lifetime in Days", ylab="Lifetime")
```


# As expected, the lifetime of a driver has no relation to the total revenue of a driver. The correlation between the two is 0.52, which can be seen by plotting the lifetime vs the total revenue. This makes sense, as a part-time driver working the same amount of time as a full-time driver will make much less. Thus, we can rule out lifetime as a factor in a driver's lifetime value.

```{r message=FALSE, warning=FALSE, include=FALSE}
#cor(driver_lifetime$total_rev[-c(425)], as.numeric(driver_lifetime$life_time[-c(425)]))
#cor(driver_lifetime$total_rev[-c(425)], as.numeric(driver_lifetime$totalprimetime[-c(425)]))
#par(mfrow=c(1,2))
plot(as.numeric(Driver_summary$life_time), Driver_summary$Total_rev, main="Total Revenue vs Lifetime", xlab="Lifetime in Days", ylab="Total Revenue in Dollars")
#plot(as.numeric(driver_lifetime$totalprimetime[-c(425)]), driver_lifetime$total_rev[-c(425)], main="Total Revenue vs Total Prime Time", xlab="Prime Time", ylab="Total Revenue in Dollars")
```
