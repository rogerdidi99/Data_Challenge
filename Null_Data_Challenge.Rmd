---
title: "Null_Data_Challenge"
author: "Roger Yuan"
date: "9/3/2019"
output: html_document
---
  
  ```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Import Datasets
```{r echo=FALSE, message=FALSE, warning=FALSE}
library(readr)
library(tidyverse)
# Roger
ride_ids <- read_csv("~/Desktop/Lyft Data Challenge/Lyft Data/ride_ids.csv")
driver_ids <- read_csv("~/Desktop/Lyft Data Challenge/Lyft Data/driver_ids.csv")
ride_timestamps <- read_csv("~/Desktop/Lyft Data Challenge/Lyft Data/ride_timestamps.csv")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(readr)
library(tidyverse)
# Edwin
ride_ids <- read_csv("C:/Users/Edwin/Downloads/ride_ids.csv")
driver_ids <- read_csv("C:/Users/Edwin/Downloads/driver_ids.csv")
ride_timestamps <- read_csv("C:/Users/Edwin/Downloads/ride_timestamps.csv")
```

##Revenue for Each Driver
```{r echo=FALSE}
ride_ids$revenue <- round(1.75 + (2 + 0.22 * ride_ids$ride_duration/60 + 1.15 * 0.000621371 * ride_ids$ride_distance) * (1 + ride_ids$ride_prime_time/100), digits = 2)

ride_ids$revenue[ride_ids$revenue < 5] <- 5
ride_ids$revenue[ride_ids$revenue > 400] <- 400

ride_ids %>% 
  group_by(driver_id) %>% 
  summarise(total_rev = sum(revenue)) %>% 
  arrange(desc(total_rev))
```

# tag rides with time of day, sum up all prime time bonuses for drivers
```{r echo=FALSE}
# switch timezone
attributes(ride_timestamps$timestamp)$tzone <- "America/Los_Angeles"

# morning rush hour 5-10
# evening rush hour 3-7
timeofday <- function(datetime) {
  num = as.numeric(strftime(datetime, format="%H"))
  if ((num < 5) | (num >= 19)) return("night")
  if ((5 <= num) & (num < 10)) return("morning rush")
  if ((10 <= num) & (num < 12)) return("morning")
  if ((12 <= num) & (num < 15)) return("afternoon")
  if ((15 <= num) & (num < 19)) return("evening rush")
  else return(NULL)
}

# assign time of day for ride based on accepted_at timestamp
acceptedat <- ride_timestamps[which(ride_timestamps$event == 'accepted_at'),]

# long function, has to run row by row
acceptedat$dayinfo <- apply(acceptedat, 1, function(x) {timeofday(x[3])})

for (i in 1:(length(acceptedat$ride_id))) {
    acceptedat$dayinfo[i] <- timeofday(acceptedat$timestamp[i])
}

ride_ids <- left_join(ride_ids, acceptedat[c("ride_id", "dayinfo")], by="ride_id")

# find total prime time bonus for each driver
sumprime <- aggregate(ride_ids$ride_prime_time, by=list(driver_id=ride_ids$driver_id), FUN=sum)
colnames(sumprime) <- c("driver_id", "totalprimetime")

# join totalprimetime bonus with driver_id table
driver_ids <- inner_join(driver_ids, sumprime, by="driver_id")

temp <- ride_ids %>% 
  group_by(driver_id) %>% 
  summarise(total_rev = sum(revenue)) %>% 
  arrange(desc(total_rev))
driver_ids <- inner_join(driver_ids, temp, by="driver_id")

```

##Driver's Lifetime
```{r echo=FALSE}
rides <- 
  ride_timestamps %>% 
  group_by(ride_id) %>% 
  summarise(latest_time = max(timestamp))
ride_ids2 <- inner_join(x = ride_ids, y = rides, by = "ride_id")

driver_times <- 
  ride_ids2 %>% 
  group_by(driver_id) %>% 
  summarise(latest_time = max(latest_time))

driver_lifetime <- inner_join(driver_ids, driver_times, "driver_id")
driver_lifetime$life_time <- driver_lifetime$latest_time - driver_lifetime$driver_onboard_date

driver_lifetime %>% arrange(desc(life_time))
mean(driver_lifetime$life_time, na.rm = T)
```

##Time Between Rides
```{r echo=FALSE}
Driver_timestamps <- left_join(x = ride_timestamps, y = ride_ids, by = "ride_id")
bruhh <- Driver_timestamps %>% 
  filter(event == "requested_at") %>% 
  arrange(timestamp) %>% 
  arrange(driver_id)

timediff <- function(time1, time2) {
  diff = difftime(time1, time2)
  if (units(diff) == "secs") {
    return(as.numeric(diff) / 60)
  }
  if (units(diff) == "hours") {
    return(as.numeric(diff) * 60)
  }
  return(as.numeric(diff))
}

bruhh2 <- bruhh %>% select(driver_id, timestamp)
bruhh2$difference = c(NA, round(diff(bruhh2$timestamp)/60))
bruhh2
```



##Big Inner Join
```{r echo=FALSE}
all_rides <- inner_join(x = ride_ids, y = driver_ids, by = "driver_id")
all_rides <- inner_join(x = all_rides, y = ride_timestamps, by = c("ride_id"))

Driver_summary <- 
  all_rides %>% 
  group_by(driver_id) %>% 
  summarise(Total_Rev = sum(revenue), life_time = max(timestamp - driver_onboard_date), 
            Total_distance = sum(ride_distance), Total_duration = sum(ride_duration),
            Total_prime_time = sum(ride_prime_time))
Driver_summary$life_time <- as.numeric(Driver_summary$life_time)/24
Driver_summary
```


# investigate timestamps of outlier drivers
```{r echo=FALSE}
# driver id and revenue
driver_rev <- ride_ids %>% 
  group_by(driver_id) %>% 
  summarise(total_rev = sum(revenue)) %>% 
  arrange(desc(total_rev))

ride_timestamps <- inner_join(ride_ids[,c('driver_id', 'ride_id')], ride_timestamps, by='ride_id')

timediff <- function(time1, time2) {
  diff = difftime(time1, time2)
  if (units(diff) == "secs") {
    return(as.numeric(diff) / 60)
  }
  if (units(diff) == "hours") {
    return(as.numeric(diff) * 60)
  }
  return(as.numeric(diff))
}

# subtract dropped off from requested time
ride_summary <- aggregate(ride_timestamps$timestamp, by=list(ride_id=ride_timestamps$ride_id), FUN=function(x)timediff(range(x)[2], range(x)[1]))
#only pickedup and droppedoff
temp2 <- ride_timestamps[which(ride_timestamps$event == 'picked_up_at' | ride_timestamps$event == 'dropped_off_at'),]
travel_times <- aggregate(temp2$timestamp, by=list(ride_id=temp2$ride_id), 
                          FUN=function(x) timediff(range(x)[2], range(x)[1]))

# get times with no revenue
ride_summary$norider <- (ride_summary$x - travel_times$x)
colnames(ride_summary)[2] <- 'totaltime'

#ride_summary$totaltime <- as.numeric(ride_summary$totaltime)
ride_summary <- inner_join(ride_ids[,c('driver_id', 'ride_id')], ride_summary, by='ride_id')
ride_summary$percentnorev <- ride_summary$norider / ride_summary$totaltime
```


```{r echo=FALSE}
# driver ids with outlier revenue
driverid_out <- driver_rev$driver_id[which(driver_rev$total_rev %in% boxplot(driver_rev$total_rev)$out)]
ride_summary[which(ride_summary$driver_id %in% driverid_out),]
meannorev <- aggregate(ride_summary$percentnorev, by=list(driver_id=ride_summary$driver_id), FUN=mean)
# ride timestamps with outlier driver revenue
time_out <- ride_timestamps[which(ride_timestamps$driver_id %in% driver_out),]
```


##OLS Regression Analysis
```{r echo=FALSE}
library(glmnet)
which(is.na(Driver_summary), arr.ind=TRUE)
Driver_summary[425, 3] <- median(Driver_summary[[3]], na.rm = T)

X <- model.matrix(Total_Rev ~., data = Driver_summary[,-1])[,-1]
Y <- Driver_summary$Total_Rev

#Creating 70% training, 30% testing data
set.seed(777)
train <- sample(1:nrow(X), round(0.7 * nrow(X)))
test <- (-train)
Y_test <- Y[test]

##OLS
driver_lm <- lm(Total_Rev ~ 0 + life_time + Total_distance + Total_duration
                + Total_prime_time, data = Driver_summary[,-1])
summary(driver_lm)

coef(driver_lm)
length(Y)

lassofit = glmnet(X, Y)
# we can see lasso will push a paramter value down to 0
as.matrix(t(coef(lassofit, s = 0.5))) 

```


```{r}
mean(ride_ids$revenue[which(ride_ids$dayinfo=='night')])
mean(driver_lifetime$life_time, na.rm=T)
lifetimesummary <- boxplot.stats(as.numeric(driver_lifetime$life_time))
lifetimesummary
```

# The average projected lifetime of a driver is approximately 55.75 days, or a little under 2 months based on the data given. Furthermore, the minimum lifetime is 1.7 days, the first quartile is 43 days, the median is 58 days, the third quartile is 73 days, and the maximum is 91 days. The distribution of lifetimes is only slightly left skewed. We calculated the lifetime of a driver by subtracting their onboard date from their last recorded ride date. However, because the data was only representative of a 3 month period the projected lifetime in this dataset is likely shorter than the true projected lifetime of a Lyft driver.
```{r message=FALSE, warning=FALSE}
boxplot(as.numeric(driver_lifetime$life_time), main="Driver Lifetime in Days", ylab="Lifetime")
```


# As expected, the lifetime of a driver has no relation to the total revenue of a driver. The correlation between the two is 0.52, which can be seen by plotting the lifetime vs the total revenue. This makes sense, as a part-time driver working the same amount of time as a full-time driver will make much less. Thus, we can rule out lifetime as a factor in a driver's lifetime value.

# Instead of a driver's lifetime, we hypothesized that a driver who works for Lyft during times of high demand, such as special events or rush hour, would be of much value to the company. Not only would they bring in more revenue due to prime time bonuses that are often in effect, but they bolster Lyft's consistency and dependency during times when people rely on them the most. Moreover, they increase Lyft's ability to contend against competitors when there are more potential riders unfamiliar with the service or are not loyal to a specific one. 

# To measure a driver's tendency to drive during times of high demand, we summed up all the prime time bonuses for each driver, as prime time bonuses reflect the demand for rides during the time a driver worked. Plotting the total prime time vs the total revenue, we can see a linear relationship between the two, whch is supported by a correlation of 0.916. 
```{r message=FALSE, warning=FALSE, include=FALSE}
cor(driver_lifetime$total_rev[-c(425)], as.numeric(driver_lifetime$life_time[-c(425)]))
cor(driver_lifetime$total_rev[-c(425)], as.numeric(driver_lifetime$totalprimetime[-c(425)]))
par(mfrow=c(1,2))
plot(as.numeric(driver_lifetime$life_time[-c(425)]), driver_lifetime$total_rev[-c(425)], main="Total Revenue vs Lifetime", xlab="Lifetime in Days", ylab="Total Revenue in Dollars")
plot(as.numeric(driver_lifetime$totalprimetime[-c(425)]), driver_lifetime$total_rev[-c(425)], main="Total Revenue vs Total Prime Time", xlab="Prime Time", ylab="Total Revenue in Dollars")
```

# Another factor that contributes to a driver's lifetime value is if they are full time or part time. Of course, a full time driver not only brings in more revenue to the company but also serve as a consistent source of it, which is more valuable than someone who is inconsistent. One way to measure this with the data given is to calculate the time between consecutive rides for each driver, and using these gaps to gauge how often a driver works. Consistently small time gaps between rides should indicate a full time driver, while larger gaps often indicate a part time driver. 

# something visual here:
```{r}
length(unique(bruhh2$driver_id[which(bruhh2$difference > 2880)]))
```


# Yet another factor that contributes to a driver's value is the time of day they work. This is somewhat related to prime time bonuses, but take into account a driver's routine or schedule rather than events or unique circumstances. To get this information we took the time each ride was requested and labelled it with a string describing the time it took place(morning, afternoon, night, morning rush hour, evening rush hour). We hypothesize that drivers who work during rush hour and night shifts not only bring in more revenue but also add to their consistency as resources to the company.
```{r}

```

